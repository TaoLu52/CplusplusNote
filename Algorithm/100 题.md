#### [1056. 易混淆数](https://leetcode.cn/problems/confusing-number/)
```c++
class Solution {

public:

    bool confusingNumber(int n) {

        vector<int> vec;

        int temp = n;

        if(n==0 || n==1 || n==8)

        {

            return false;

        }

        while(temp>0)

        {

            int r = temp%10;

            temp=temp/10;

            if(!isconfuis(r))

            {

                return false;

            }

            vec.push_back(r);      

        }

        if(vec.size()==1)

        {

            return true;

        }

        int m=1;

        int n_s=0;

        int cnt=0;

        for(cnt=0;cnt<vec.size();cnt++)

        {

            int x=retconfuis(vec[vec.size()-cnt-1]);

            n_s+=x*m;

            m=m*10;

        }

        if(n_s==n)

        {

            return false;

        }

        return true;

    }

    bool isconfuis(int n)

    {

        switch(n)

        {

            case 0:

            case 1:

            case 6:

            case 8:

            case 9:

                return true;

            case 2:

            case 3:

            case 4:

            case 5:

            case 7:

                return false;

        }

        return true;

    }

    int retconfuis(int n)

    {

        switch(n)

        {

            case 0:

                return 0;

            case 1:

                return 1;

            case 6:

                return 9;

            case 8:

                return 8;

            case 9:

                return 6;

        }

        return -1;

    }

};
```

#### [1427. 字符串的左右移](https://leetcode.cn/problems/perform-string-shifts/)
```c++
class Solution {

public:

    string stringShift(string s, vector<vector<int>>& shift) {

        string ret=s;

        for(vector<int>& vec : shift)

        {

            int shift =getreasonableshift(ret, vec[1]);

            if(vec[0]==0)

            {

                leftShift(ret, shift);

            }

            if(vec[0]==1)

            {

                rightShift(ret,shift);

            }

        }

        return ret;

    }

    int getreasonableshift(string &s,int shift)

    {

        int len=s.size();

        int ret=0;

        ret= shift%len;

        return ret;

    }

    void leftShift(string &s, int left)

    {

        string temp1 = s.substr(0,left);

        string temp2 = s.substr(left, s.size());

        s=temp2+temp1;

        return;

    }

    void rightShift(string &s, int right)

    {

        string temp1 = s.substr(0,s.size()-right);

        string temp2 = s.substr(s.size()-right, s.size());

        s=temp2+temp1;

        return;

    }

};
```

#### [624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)
```c++
class Solution {

public:

    int maxDistance(vector<vector<int>>& arrays) {

        vector<vector<int>> vec;

        int cnt=0;

        for(vector<int>& a : arrays)

        {

            vec.push_back({a.front(),cnt,a.back()});

            cnt++;

        }

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[0]<b[0];

        });

        vector<vector<int>> vecf=vec;

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[2]>b[2];

        });

        vector<vector<int>> vecb=vec;

        int ret = search(vecf,vecb,0,0);

        return ret;

    }

    int search(vector<vector<int>>& vecf,vector<vector<int>>vecb,int cntf,int cntb)

    {

        cout<<"cntf:"<<cntf<<" cntb:"<<cntb<<endl;

        cout<<vecb[cntb][2]<<","<<vecf[cntf][0]<<endl;

        if(cntf>=vecf.size())

        {

            return INT_MIN;

        }

        if(cntb>=vecb.size())

        {

            return INT_MIN;

        }

        if(vecf[cntf][1]!=vecb[cntb][1])

        {

            return vecb[cntb][2]-vecf[cntf][0];

        }

        int ret1 = search(vecf,vecb,cntf+1,cntb);

        int ret2 = search(vecf,vecb,cntf,cntb+1);

  

        int ret= max(ret1, ret2);

        return ret;

    }

};
```
#### [280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)
```c++
class Solution {

public:

    void wiggleSort(vector<int>& nums) {

        sort(nums.begin(),nums.end());

        int i=1;

        int j=2;

        int temp=0;

        while(i<nums.size() && j<nums.size())

        {

            temp=nums[i];

            nums[i]=nums[j];

            nums[j]=temp;

            i=i+2;

            j=j+2;

        }

        return;

    }

};
```

#### [161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)
双指针
```c++
class Solution {

public:

    // int flag=0;

    bool isOneEditDistance(string s, string t) {

        if(strcmp(s.c_str(),t.c_str())==0)

        {

            return false;

        }

        int ret = checkstring(s,t,0,0,0);

  

        return ret;

    }

    bool checkstring(string &s, string &t, int cnt1,int cnt2, int flag)

    {

        if(max(s.size(),t.size())-min(s.size(),t.size())>1)

        {

            return false;

        }

        if(flag>1)

        {

            return false;

        }

        if((cnt1==s.size() && cnt2==t.size()-1)||(cnt1==s.size()-1 && cnt2==t.size()))

        {

            return true;

        }

        int cnts=cnt1,cntt=cnt2;       

        int cnt=flag;

        while(cnts<s.size() && cntt < t.size())

        {

            if(s[cnts]==t[cntt])

            {

                cnts++;

                cntt++;

            }

            else

            {

                cnt++;

                int ret1 = 0 ,ret2 = 0;

                if(s.size()!=t.size())

                {

                    ret1 = checkstring(s,t,cnts,cntt+1,cnt);

                    ret2 = checkstring(s,t,cnts+1,cntt,cnt);

                }

                else

                {

                    ret1 = checkstring(s,t,cnts+1,cntt+1,cnt);

                }

                if(ret1||ret2)

                {

                    return true;

                }

                else

                {

                    return false;

                }

            }

        }

        if((cnts==s.size() && cntt != t.size()) || (cnts != s.size() && cntt == t.size()))

        {

            if(cnt!=0)

            {

                return false;

            }

        }

        return true;

    }

};
```
#### [186. 反转字符串中的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
这道题原地反转会更麻烦，需要相对坐标变换
```c++
class Solution {

public:

    void reverseWords(vector<char>& s) {

        char c = ' ';

        vector<int> vec;

        for(int cnt=0;cnt<s.size();cnt++)

        {

            if(s[cnt]==c)

            {

                vec.push_back(cnt);

            }

        }

        int prev= s.size();

        int lastp=0;

        vector<string> svec;

        int start=0;

        int end=0;

        string temp;

        for(int cnt=0;cnt<vec.size();cnt++)

        {

            end = vec[cnt];

  

            for(int subcnt=start;subcnt<end;subcnt++ )

            {

                temp+=s[subcnt];

            }

            start = end+1;

            svec.push_back(temp);

            temp.clear();

        }

        for(int subcnt=start;subcnt<s.size();subcnt++ )

        {

            temp+=s[subcnt];

        }

        svec.push_back(temp);

        string ret;

        for(int cnt = svec.size()-1;cnt>=0;cnt--)

        {

            ret+=svec[cnt];

            if(cnt!=0)

            {

                ret+=' ';

            }

        }

        for(int i=0;i<ret.size();i++)

        {

            s.push_back(ret[i]);

        }

        s.erase(s.begin(), s.begin()+ret.size());

        return;

    }

};
```


#### [159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
滑动窗口
```c++
class Solution {

public:

    int lengthOfLongestSubstringTwoDistinct(string s) {

        unordered_map<char,int> umap;

        int cnt=0;

        int left=0,right=0;

        char c;

        int len=0;

        while(right<s.size())

        {

            c= s[right];

            if(umap[c]==0)

            {

                cnt++;

            }

            umap[c]++;

            right++;

            if(cnt<=2)

            {

  

            }

            else

            {

                len = max(len,right-1-left);

                while(left<=right)

                {

                    c = s[left];

                    umap[c]--;

                    left++;

                    if(umap[c]==0)

                    {

                        cnt--;

                    }

                    if(cnt<3)

                    {

                        break;

                    }

                }                

            }

        }

        if(cnt<=2)

        {

            len=max(len,right-left);

        }

        return len;

    }

};
```

#### [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
```c++
class Solution {

public:

    int lengthOfLongestSubstringKDistinct(string s, int k) {

        unordered_map<char,int> umap;

        int cnt=0;

        int left=0,right=0;

        char c;

        int len=0;

        while(right<s.size())

        {

            c= s[right];

            if(umap[c]==0)

            {

                cnt++;

            }

            umap[c]++;

            right++;

            if(cnt<=k)

            {

                continue;

            }

            else

            {

                len = max(len,right-1-left);

                while(left<=right)

                {

                    c = s[left];

                    umap[c]--;

                    left++;

                    if(umap[c]==0)

                    {

                        cnt--;

                    }

                    if(cnt<=k)

                    {

                        break;

                    }

                }                

            }

        }

        if(cnt<=k)

        {

            len=max(len,right-left);

        }

        return len;

    }

};
```
#### [487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)
```c++
class Solution {

public:

    int findMaxConsecutiveOnes(vector<int>& nums) {

        int cnt  = 0;

        int prev = 0;

        int left=0,right=0;

        int len=0;

        int flag=0;

        for(cnt=0;cnt<nums.size();cnt++)

        {

  

            if(nums[cnt]==0)

            {

                flag=1;

                right=cnt-prev;

                len=max(right+left+1,len);

                left=right;

                prev=cnt+1;

            }

        }

  

        right=cnt-prev;

        len=max(right+left+1,len);

        if(flag==0)

        {

            return nums.size();

        }

        return len;

    }

};
```
#### [760. 找出变位映射](https://leetcode.cn/problems/find-anagram-mappings/)
```c++
class Solution {

public:

    vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {

        unordered_map<int,int> umapB;

        for(int i=0;i<nums2.size();i++)

        {

            umapB[nums2[i]]=i;

        }

        vector<int> P;

        for(int i=0;i<nums1.size();i++)

        {

            int l = umapB[nums1[i]];

            P.push_back(l);

        }

        return P;

    }

};
```
#### [266. 回文排列](https://leetcode.cn/problems/palindrome-permutation/)
```c++
class Solution {

public:

    bool canPermutePalindrome(string s) {

        unordered_map<char,int> umap;

        for(char c : s)

        {

            umap[c]++;

        }

        int flag=0;

        for(auto c : umap)

        {

            if(c.second%2!=0)

            {

                flag++;

            }

            else

            {

                ;

            }

            if(flag>1)

            {

                return false;

            }

        }

        return true;

    }

};
```
#### [734. 句子相似性](https://leetcode.cn/problems/sentence-similarity/)
```c++
class Solution {

public:

    bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {

        if(sentence1.size()!=sentence2.size())

        {

            return false;

        }

        unordered_map<string, unordered_set<string>> umapsp;

        for(auto c : similarPairs)

        {

            umapsp[c.front()].emplace(c.back());

            umapsp[c.back()].emplace(c.front());

        }

        int flag=0;

        int i=-1;

        for(auto c : sentence1)

        {

            i++;

            string & temp=sentence2[i];

            if(c==temp)

            {

                continue;

            }

            else

            {

                if(umapsp.find(c)!=umapsp.end())

                {

                    if(umapsp[c].find(temp)!=umapsp[c].end())

                    {

                        continue;

                    }

                }

            }

            return false;

        }

        return true;

    }

};
```

#### [1165. 单行键盘](https://leetcode.cn/problems/single-row-keyboard/)
```c++
class Solution {

public:

    int calculateTime(string keyboard, string word) {

        int prev=0;

        int offset=(int)'a'-0;

        int time=0;

        int cnt=0;

        unordered_map<char,int>umap;

        for(auto c : keyboard)

        {

  

            umap[c]=cnt;

            cnt++;

        }

        for(auto c :word)

        {

  

            time+=max(umap[c],prev)-min(umap[c],prev);

            prev=umap[c];

        }

        return time;

    }

};
```

#### [249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)
这道题比较卡的地方是超过z要回到a;
```c++
class Solution {

public:

    vector<vector<string>> groupStrings(vector<string>& strings) {

        unordered_map<int,vector<vector<string>>> umap;

        for(int i=0;i<strings.size();i++)

        {

            string & temp = strings[i];

            if(umap.find(temp.size())==umap.end())

            {

                umap[temp.size()].push_back({temp});

            }

            else

            {

                int flag=0;

                for(int i=0; i< umap[temp.size()].size();i++)

                {

                    string & x = umap[temp.size()][i].front();

                    if(isSimString(temp,x))

                    {

                        umap[temp.size()][i].push_back(temp);

                        flag=1;

                        break;

                    }

                }

                if(flag==0)

                {

                    umap[temp.size()].push_back({temp});

                }

            }

        }

        vector<vector<string>> ret;

        for(auto temppair : umap)

        {

            vector<string> vec;

            auto vectemp=temppair.second;

            for(auto c :vectemp)

            {

                ret.push_back(c);

            }

        }

        return ret;

    }

    bool isSimString(string & s1, string &s2)

    {

        string a;

        string b;

        if(s1.size()!=s2.size())

        {

            return false;

        }

  

        if(s1.front()>s2.front())

        {

            a=s1,b=s2;

        }

        else

        {

            a=s2,b=s1;

        }

        int offset = a.front() - b.front();

  

        int i=0;

        for(i=0;i<s1.size();i++)

        {

            if(b[i]+offset>'z')

            {

                if(a[i]-'a'+1==b[i]+offset-'z')

                {

                   continue;// return true;

                }

                else

                {

                    return false;

                }

            }

            else

            {

                if(a[i]-b[i]==offset)

                {

                    continue;//return true;

                }

                else

                {

                    return false;

                }

            }

        }

        return true;

    }

};
```
#### [422. 有效的单词方块](https://leetcode.cn/problems/valid-word-square/)
```c++
class Solution {

public:

    bool validWordSquare(vector<string>& words) {

        string stemp;

        for(int i=0;i<words.size();i++)

        {

            stemp.clear();

            for(int j=0;j<words.size();j++)

            {

                if(words[j].size()>i)

                    stemp+=words[j][i];

            }

            if(words[i]==stemp)

            {

                continue;

            }

            else

            {

                return false;

            }

        }

        return true;

    }

};
```

#### [531. 孤独像素 I](https://leetcode.cn/problems/lonely-pixel-i/)
```c++
class Solution {

public:

    vector<int> line;

    vector<int> row;

    int findLonelyPixel(vector<vector<char>>& picture) {

        int cnt=0;

        line=vector<int>(picture.size(),-1);

        row=vector<int>(picture.front().size(),-1);

        for(int y=0;y<picture.size();y++)

        {

            for(int x=0;x<picture.front().size();x++)

            {

                int ret = checkB(picture, x, y);

                if(ret==1)

                {

                    cnt++;

                    cout<<x<<","<<y<<endl;

                }

            }

        }

        return cnt;

    }

    int checkB(vector<vector<char>>& picture, int x, int y)

    {

        if(picture[y][x]!='B')

        {

            return 0;

        }

        int ret1 = checkline(picture, y);

        int ret2 = checkrow(picture, x);

  

        if(ret1==1 && ret2 ==1)

        {

            return 1;

        }

        else

        {

            return -1;

        }

    }

    int checkline(vector<vector<char>>& picture, int y)

    {

        int cnt=0;

        int i=0;

        if(line[y]>=0)

        {

            return line[y];

        }

        for(int i=0;i<picture.front().size();i++)

        {

            if(picture[y][i]=='B')

            {

                cnt++;

            }

        }

        line[y]=cnt;

        return cnt;

    }

    int checkrow(vector<vector<char>>& picture, int x)

    {

        int cnt=0;

        int i=0;

        if(row[x]>=0)

        {

            return row[x];

        }

        for(int i=0;i<picture.size();i++)

        {

            if(picture[i][x]=='B')

            {

                cnt++;

            }

        }

        row[x]=cnt;

        return cnt;

    }

};
```
#### [311. 稀疏矩阵的乘法](https://leetcode.cn/problems/sparse-matrix-multiplication/)
```c++
class Solution {

public:

    vector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {

        int size = min(mat1.size(),mat2.front().size());

        vector<vector<int>> rmat2=reverse(mat2);

        vector<vector<int>> vret;

        for(int i=0;i<mat1.size();i++)

        {

            vector<int> temp;

            for(int j=0;j<rmat2.size();j++)

            {

                int m = lineMultirow(mat1[i],rmat2[j]);

                temp.push_back(m);

            }

            vret.push_back(temp);

            temp.clear();

        }

        return vret;

    }

    vector<vector<int>> reverse(vector<vector<int>>& mat2)

    {

        vector<vector<int>> ret;

        for(int x=0;x<mat2.front().size();x++)

        {

            vector<int> temp;

            for(int y=0;y<mat2.size();y++)

            {

                temp.push_back(mat2[y][x]);

            }

            ret.push_back(temp);

            temp.clear();

        }

        return ret;

    }

    int lineMultirow(vector<int>& line,vector<int>& row)

    {

        int size = line.size();

        int ret=0;

        for(int i=0;i<size;i++)

        {

            ret+=line[i]*row[i];

        }

        return ret;

    }

};
```
#### [163. 缺失的区间](https://leetcode.cn/problems/missing-ranges/)
```c++
class Solution {

public:

    vector<vector<int>> findMissingRanges(vector<int>& nums, int lower, int upper) {

        if(nums.empty())

        {

            return {{lower,upper}};

        }

        vector<int> ret = findMissingNum(nums,lower,upper);

        vector<vector<int>> vret;

        if(lower<ret.front())

        {

            vret.push_back({lower, ret.front()-1});

        }

        int cnt=1;

        for(;cnt<ret.size()-1;cnt++)

        {

            vret.push_back({ret[cnt],ret[cnt+1]});

            cnt++;

        }

        if(upper>ret.back())

        {

            vret.push_back({ ret.back()+1,upper});

        }

        return vret;

    }

    vector<int> findMissingNum(vector<int>& nums, int lower, int upper)

    {

        int cnt=0;

        int prev=nums.front();

        vector<int> ret;

        for(cnt=0;cnt<nums.size();cnt++)

        {

            if(cnt==0)

            {

                ret.push_back(nums[cnt]);

                continue;

            }

            if(nums[cnt]!=prev+1)

            {

                ret.push_back(prev+1);

            }

            prev=nums[cnt];

        }

        prev=nums.back();

        for(cnt=nums.size()-1;cnt>=0;cnt--)

        {

            if(cnt==nums.size()-1)

            {

                ret.push_back(nums[cnt]);

                continue;

            }

            if(nums[cnt]!=prev-1)

            {

                ret.push_back(prev-1);

            }

            prev=nums[cnt];

        }

        sort(ret.begin(),ret.end());

        return ret;

    }

};
```
#### [252. 会议室](https://leetcode.cn/problems/meeting-rooms/)
```c++
class Solution {

public:

    bool canAttendMeetings(vector<vector<int>>& intervals) {

        if(intervals.empty())

        {

            return true;

        }

        sort(intervals.begin(),intervals.end(),[](vector<int> &a, vector<int> &b){return a[0]<b[0];});

        for(int i=0; i<intervals.size()-1;i++)

        {

            if(intervals[i][1]<=intervals[i+1][0])

            {

                continue;

            }

            else

            {

                return false;

            }

        }

        return true;

    }

};
```




#### [253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)
有一个特别注意的细节：
```c++
        // for(auto a : vrec)

        // {

        //     intervals.erase(intervals.begin()+a,intervals.begin()+a+1);

        // }
```
使用这种方式删除会出错。因为这种方式会导致目标元素的位置不断变化。
```c++
class Solution {

public:

    vector<int> grec;

    int minMeetingRooms(vector<vector<int>>& intervals) {

        int meetingcnt=0;

        int ret=0;

        int roomcnt=0;

        vector<vector<int>> svec = intervals;

        grec=vector<int>(intervals.size(),0);

        sort(svec.begin(),svec.end(),[](vector<int>&a , vector<int>&b)

        {

            return a[0]<b[0];

        });

        vector<int> vrec;

  

        int prev=0;

        //while(!svec.empty())

        while(meetingcnt<intervals.size())

        {

            ret = pickupmeeting(svec, meetingcnt);

            if(ret!=0)

            {

                roomcnt++;

            }

        }

  

        return roomcnt;

    }

    int pickupmeeting(vector<vector<int>>& intervals, int &meetingcnt)

    {

        vector<int> vrec;

        int prev=0;

        int i=0;

        while(i<grec.size())

        {

            if(grec[i]==0)

            {

                break;

            }

            i++;

        }

        if(i==grec.size())

        {

            return 0;

        }

        prev=i;

        grec[i]=1;

        vrec.push_back(prev);

        meetingcnt++;

        for(int i=prev+1;i<intervals.size();i++)

        {

            int ret=0;

            if(grec[i]==1)

            {

                continue;

            }

            ret = isnotConflict(intervals,  prev, i);

            if(ret)

            {

                vrec.push_back(i);

                prev=i;

                grec[i]=1;

                meetingcnt++;

            }            

        }        

        // for(auto a : vrec)

        // {

        //     intervals.erase(intervals.begin()+a,intervals.begin()+a+1);

        // }

        return 1;

    }

    int isnotConflict(vector<vector<int>>& intervals, int prev, int current)

    {

        if(intervals[prev][1]<=intervals[current][0] && intervals[prev][0]<intervals[current][0])

        {

            return true;

        }

        else if (intervals[prev][1]>=intervals[current][0] && intervals[prev][0]>intervals[current][0])

        {

            return true;

        }

        else

        {

            return false;

        }

    }

};
```
#### [439. 三元表达式解析器](https://leetcode.cn/problems/ternary-expression-parser/)
栈的典型应用
```c++
class Solution {

public:

    string parseTernary(string expression) {

        stack<char> vstack;

        stack<char> backstack;

        int cnt=0;

        string::reverse_iterator it  = expression.rbegin();

        int flag=0;

        for(;it!=expression.rend();it++)

        {

            if(flag==0)

            {

                if(*it != '?')

                {

                    vstack.push(*it);

                }

                else

                {

                    flag=1;

                }

            }

            else

            {

                if(*it!='T' && *it != 'F')

                {

                    cout<<"error"<<endl;

                    return "error!";

                }

                else

                {

                    if(*it=='T')

                    {

                        while(vstack.top()!=':')

                        {

                            backstack.push(vstack.top());

                            vstack.pop();

                        }

                        vstack.pop();//':'

                        while(!vstack.empty()&&vstack.top()!=':')

                        {

                            //backstack.push(vstack.top());

                            vstack.pop();

                        }

                    }

                    else

                    {

                        while(vstack.top()!=':')

                        {

                            //backstack.push(vstack.top());

                            vstack.pop();

                        }

                        vstack.pop();//':'

                        while(!vstack.empty()&&vstack.top()!=':')

                        {

                            backstack.push(vstack.top());

                            vstack.pop();

                        }                        

                    }

                    while(!backstack.empty())

                    {

                        vstack.push(backstack.top());

                        backstack.pop();

                    }

                }

                flag=0;

            }

        }

        string ret;

        while(!vstack.empty())

        {

            ret+=vstack.top();

            vstack.pop();

        }

        return ret;

    }

};
```
#### [484. 寻找排列](https://leetcode.cn/problems/find-permutation/)
```c++
class Solution {

public:

    vector<int> findPermutation(string s) {

        int cnt=0;

        vector<int> vec;

        stack<int> st;

        for(cnt=0;cnt<s.size();cnt++)

        {

            if(s[cnt]=='I')

            {

                if(st.empty())

                {

                    vec.push_back(cnt+1);

                }

                else

                {

                    st.push(cnt+1);

                    while(!st.empty())

                    {

                        vec.push_back(st.top());

                        st.pop();

                    }

                }

            }

            else

            {

                st.push(cnt+1);

            }

        }

        if(s.back()!='I')

        {

            st.push(cnt+1);

            while(!st.empty())

            {

                vec.push_back(st.top());

                st.pop();

            }

        }

        else

        {

            vec.push_back(cnt+1);

        }

  

        return vec;

    }

};
```
#### [346. 数据流中的移动平均值](https://leetcode.cn/problems/moving-average-from-data-stream/)
```c++
class MovingAverage {

public:

    queue<int> que;

    int qsize=0;

    int sum=0;

    MovingAverage(int size) {

        qsize=size;

    }

    double next(int val) {

        que.push(val);

        sum+=val;

        while(que.size()>qsize)

        {

            sum-=que.front();

            que.pop();            

        }

        double avg=0;

        int quenum =que.size();

        int num = min(quenum,qsize);

        avg=(double)sum/(double)num;

        return avg;

    }

};

  

/**

 * Your MovingAverage object will be instantiated and called as such:

 * MovingAverage* obj = new MovingAverage(size);

 * double param_1 = obj->next(val);

 */
```
#### [1429. 第一个唯一数字](https://leetcode.cn/problems/first-unique-number/)
```c++
class FirstUnique {

public:

    queue<int> que;

    unordered_map<int, int> umap;

    queue<int> tmpque;

    FirstUnique(vector<int>& nums) {

        // cout<<1<<endl;

        for(int a : nums)

        {

            que.push(a);

            umap[a]++;

        }

        tmpque=que;//构造时同步

        return;        

    }

    int showFirstUnique() {

        // cout<<2<<endl;

        // if(tmpque.empty())

        // {

        //     tmpque=que;  

        // }//只有在tmpque为空时才和que同步。节省时间

        while((!tmpque.empty()) && umap[tmpque.front()]!=1)//必须先判断tmpque是否为空

        {

            tmpque.pop();

        }

        // cout<<2.1<<endl;

        if(tmpque.empty())

        {

            return -1;

        }

        // cout<<2.1<<endl;

        return tmpque.front();

    }

    void add(int value) {

        // cout<<3<<endl;

        que.push(value);

        tmpque.push(value);

        umap[value]++;

        return;

    }

};

  

/**

 * Your FirstUnique object will be instantiated and called as such:

 * FirstUnique* obj = new FirstUnique(nums);

 * int param_1 = obj->showFirstUnique();

 * obj->add(value);

 */
```

#### [1474. 删除链表 M 个节点之后的 N 个节点](https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/)
```c++
/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode() : val(0), next(nullptr) {}

 *     ListNode(int x) : val(x), next(nullptr) {}

 *     ListNode(int x, ListNode *next) : val(x), next(next) {}

 * };

 */

class Solution {

public:

    ListNode* deleteNodes(ListNode* head, int m, int n) {

        int cntkeep=0;

        int keepflag=0;

        int cntdel=0;

        int delflag=0;

        ListNode* pNode=head;

        ListNode* pHead=head;

        ListNode* pKeep=head;

        while(pNode!=nullptr)

        {

            while(cntkeep<m && pNode!=nullptr)

            {

                if(keepflag==0)

                {

                    pHead=pNode;

                    keepflag=1;

                }

                cntkeep++;

                if(cntkeep == m)

                {

                    pKeep=pNode;

                }

                pNode=pNode->next;

            }

  

            cntkeep=0;

            while(cntdel<n && pNode!=nullptr)

            {

                delflag=1;

                pNode=pNode->next;

                cntdel++;

            }

            cntdel=0;

            if(delflag)

                pKeep->next=pNode;//只有再删过之后才需要续上之后的节点

            delflag=0;

        }

        return pHead;

    }

};
```
#### [708. 循环有序列表的插入](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/)
```c++
/*

// Definition for a Node.

class Node {

public:

    int val;

    Node* next;

  

    Node() {}

  

    Node(int _val) {

        val = _val;

        next = NULL;

    }

  

    Node(int _val, Node* _next) {

        val = _val;

        next = _next;

    }

};

*/

  

class Solution {

public:

    Node* insert(Node* head, int insertVal) {

        Node * pnode;

        if(head == nullptr)

        {

            pnode = new Node(insertVal);

            pnode->next=pnode;

            return pnode;

        }    

        pnode=head;

        Node * pTemp;

        int flag=0;

        Node *pmax=head;

        Node *pmin=head;

        while(pnode->next!=head)

        {

            if(pnode->val>pmax->val)

            {

                pmax=pnode;

            }

            if(pnode->val<pmin->val)

            {

                pmin=pnode;

            }

            //in the same loop

            if((pnode->next->val>=insertVal && pnode->val<=insertVal))

            {

                pTemp=pnode->next;

                pnode->next=new Node(insertVal);

                pnode->next->next=pTemp;

                flag=1;

                break;

            }

            pnode=pnode->next;

            if(pnode->val>=pmax->val)

            {

                pmax=pnode;

            }

            if(pnode->val<=pmin->val)

            {

                pmin=pnode;

            }

        }

        if(flag==0)

        {

            if(insertVal>pmax->val)

            {

                pnode=pmax;

                pTemp=pnode->next;

                pnode->next=new Node(insertVal);

                pnode->next->next=pTemp;

            }

            else if(insertVal<pmin->val)

            {

                pnode=pmax;

                pTemp=pnode->next;

                pnode->next=new Node(insertVal);

                pnode->next->next=pTemp;

            }

            else

            {

                pTemp=pnode->next;

                pnode->next=new Node(insertVal);

                pnode->next->next=pTemp;

            }

  

        }

        return head;

    }

};
```

#### [369. 给单链表加一](https://leetcode.cn/problems/plus-one-linked-list/)
```c++
/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode() : val(0), next(nullptr) {}

 *     ListNode(int x) : val(x), next(nullptr) {}

 *     ListNode(int x, ListNode *next) : val(x), next(next) {}

 * };

 */

 #define MBIT 10

class Solution {

public:

    ListNode* plusOne(ListNode* head) {

        vector<ListNode *> vec;

        ListNode * pnode=head;

        int carrybit=0;

        while(pnode!=nullptr)

        {

            vec.push_back(pnode);

            pnode=pnode->next;

        }

        for(int i = vec.size()-1;i>=0;i--)

        {

            if(i == vec.size()-1)

            {

                if(vec[i]->val+1>=MBIT)

                {

                    vec[i]->val=vec[i]->val+1-MBIT;

                    carrybit=1;

                }

                else

                {

                    vec[i]->val=vec[i]->val+1;

                    carrybit=0;

                }

            }

            else

            {

                if(vec[i]->val+carrybit>=MBIT)

                {

                    vec[i]->val = vec[i]->val+carrybit-MBIT;

                    carrybit=1;

                }

                else

                {

                    vec[i]->val = vec[i]->val+carrybit;

                    carrybit=0;

                }

            }

        }

        ListNode * pret;

        if(carrybit==1)

        {

            pret = new ListNode(1);

            pret->next=head;

        }

        else

        {

            pret=head;

        }

        return pret;

    }

};
```

#### [298. 二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
解法一：
```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int longestConsecutive(TreeNode* root) {

        int cnt=0;

        queue<TreeNode* >que;        

        que.push(root);

        int s1=que.size();

        vector<int>vret;

        int retmax=0;

        while(!que.empty())

        {

            for(int i=0; i<s1;i++)

            {

                TreeNode * pnode = que.front();

                if(pnode->left!=nullptr)

                {

                    que.push(pnode->left);

                }

                if(pnode->right!=nullptr)

                {

                    que.push(pnode->right);

                }

                int ret = trynextnode(pnode,cnt);

                vret.push_back(++cnt);

                que.pop();

                cnt=0;

            }

  

            s1=que.size();

        }

        sort(vret.begin(),vret.end());

        retmax= max(vret.back(),retmax);

        vret.clear();

        return retmax;

    }

    int isConsec(TreeNode* pfnode, TreeNode* psnode)

    {

        //caller should guarantee the validation of parameters

        if(psnode==nullptr)

        {

            return -1;

        }

        if(pfnode->val==psnode->val-1)

        {

            return 1;

        }

        else

        {

            return -1;

        }

    }

    int trynextnode(TreeNode * pnode, int &cnt)

    {

        int templeft  = cnt;

        int tempright = cnt;

        if(isConsec(pnode,pnode->left)>0)

        {

            cnt++;

            trynextnode(pnode->left, cnt);

        }

        templeft=cnt;

        cnt=tempright;

        if(isConsec(pnode,pnode->right)>0)

        {

            cnt++;

            trynextnode(pnode->right, cnt);            

        }

        tempright = cnt;

        cnt = max(tempright,templeft);

        // pnode->val=INT_MAX;

        return max(templeft,tempright);

    }

};
```
解法二：检查过的节点做标注，以免重复检查
```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int longestConsecutive(TreeNode* root) {

        int cnt=0;

        queue<TreeNode* >que;        

        que.push(root);

        int s1=que.size();

        vector<int>vret;

        int retmax=0;

        while(!que.empty())

        {

            for(int i=0; i<s1;i++)

            {

                TreeNode * pnode = que.front();

                if(pnode->left!=nullptr)

                {

                    que.push(pnode->left);

                }

                if(pnode->right!=nullptr)

                {

                    que.push(pnode->right);

                }

                if(pnode->val!=INT_MAX)

                {

                    trynextnode(pnode,cnt);

                }                

                vret.push_back(++cnt);

                que.pop();

                cnt=0;

            }

  

            s1=que.size();

        }

        sort(vret.begin(),vret.end());

        retmax= max(vret.back(),retmax);

        vret.clear();

        return retmax;

    }

    int isConsec(TreeNode* pfnode, TreeNode* psnode)

    {

        //caller should guarantee the validation of parameters

        if(psnode==nullptr)

        {

            return -1;

        }

        if(pfnode->val==psnode->val-1)

        {

            return 1;

        }

        else

        {

            return -1;

        }

    }

    int trynextnode(TreeNode * pnode, int &cnt)

    {

        int templeft  = cnt;

        int tempright = cnt;

        if(isConsec(pnode,pnode->left)>0)

        {

            cnt++;

            trynextnode(pnode->left, cnt);

        }

        templeft=cnt;

        cnt=tempright;

        if(isConsec(pnode,pnode->right)>0)

        {

            cnt++;

            trynextnode(pnode->right, cnt);            

        }

        tempright = cnt;

        cnt = max(tempright,templeft);

        pnode->val=INT_MAX;

        return max(templeft,tempright);

    }

};
```

#### [549. 二叉树中最长的连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/description/?envType=study-plan-v2&envId=premium-algo-100)

```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int longestConsecutive(TreeNode* root) {

        vector<int> vlen;

        int incTemp[2]={0,0};

        int decTemp[2]={0,0};

        GetInc_Dec(root,incTemp,decTemp,vlen);

        if(vlen.size()==0)

        {

            return 0;

        }

        sort(vlen.begin(),vlen.end());

        return vlen.back();

    }

    int GetInc_Dec(TreeNode * pnode,int Inc[],int Dec[],vector<int>& vlen)

    {

        int incNext[2]={0,0};

        int decNext[2]={0,0};

        int incTemp[2]={0,0};

        int decTemp[2]={0,0};

        if(pnode == nullptr)

        {

            return -1;

        }

        if(pnode->left != nullptr)

        {

            GetInc_Dec(pnode->left, incNext,decNext,vlen);

            if(pnode->val-pnode->left->val==1)

            {

                decTemp[0]=max(decNext[0],decNext[1])+1;

            }

            if(pnode->val-pnode->left->val==-1)

            {

                incTemp[0]=max(incNext[0],incNext[1])+1;

            }

        }

        if(pnode->right != nullptr)

        {

            GetInc_Dec(pnode->right, incNext,decNext,vlen);

            if(pnode->val-pnode->right->val==1)

            {

                decTemp[1]=max(decNext[0],decNext[1])+1;

            }

            if(pnode->val-pnode->right->val==-1)

            {

                incTemp[1]=max(incNext[0],incNext[1])+1;

            }

        }

        int len = max(incTemp[0]+decTemp[1],incTemp[1]+decTemp[0])+1;

        vlen.push_back(len);

        Inc[0]=incTemp[0];

        Inc[1]=incTemp[1];

        Dec[0]=decTemp[0];

        Dec[1]=decTemp[1];

        return 1;

    }

};
```
```

```
```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int max_length = 0;

    int longestConsecutive(TreeNode* root) {

        dfs(root);

        return max_length;

    }

    pair<int,int> dfs(TreeNode* node){

        // 自底向上更新inc和dcr

        if(node == NULL){

            return make_pair(0,0);

        }

        auto left = dfs(node->left);

        auto right = dfs(node->right);

        int inc_l = left.first + 1, dcr_l = left.second + 1;

        int inc_r = right.first + 1, dcr_r = right.second + 1;

        if(node->left != nullptr && (node->left->val != node->val + 1)){

            inc_l = 1;

        }

        if(node->left != nullptr && (node->left->val != node->val - 1)){

            dcr_l = 1;

        }

        if(node->right != nullptr && (node->right->val != node->val + 1)){

            inc_r = 1;

        }

        if(node->right != nullptr && (node->right->val != node->val - 1)){

            dcr_r = 1;

        }

        int inc = max(inc_l, inc_r);

        int dcr = max(dcr_l, dcr_r);

        max_length = max(max_length, inc+dcr-1);

        return make_pair(inc, dcr);

    }

};
```
#### [250. 统计同值子树](https://leetcode.cn/problems/count-univalue-subtrees/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int subcnt=0;

    int countUnivalSubtrees(TreeNode* root) {

        int val=0;

        SameSubtree(root,val);

        return subcnt;

    }

    //ret  1 same

    //     0 different

    int SameSubtree(TreeNode * pnode, int &node_val)

    {

        int lret=0;

        int rret=0;

        int ltemp=INT_MAX;

        int rtemp=INT_MAX;

        if(pnode == nullptr)

        {

            return 1;

        }

        if(pnode->left == nullptr && pnode->right == nullptr)

        {

            subcnt++;

            // cout<<"access leaf"<<endl;

            node_val=pnode->val;

            return 1;

        }

        // if(pnode->left != nullptr)

        // {

        //     lret = SameSubtree(pnode->left,ltemp);

        // }

        // if(pnode->right != nullptr)

        // {

        //     rret = SameSubtree(pnode->left,rtemp);

        // }

        lret = SameSubtree(pnode->left,ltemp);

        rret = SameSubtree(pnode->right,rtemp);

  

        if(lret && rret && ((ltemp==pnode->val)||(ltemp==INT_MAX)) && ((rtemp==pnode->val)||(rtemp==INT_MAX)) )

        {

            subcnt++;

            node_val=pnode->val;

            return 1;

        }

        else

        {

            return 0;

        }

    }

};
```

#### [270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int des;

    int closestValue(TreeNode* root, double target) {

        int l,r;

        l=root->val;

        r=root->val;

        TreeNode * pnode = root;

  

        while(pnode!=nullptr)

        {

            if(pnode->val>target)

            {

                r=pnode->val;

                pnode = pnode->left;

            }

            else if(pnode->val<target)

            {

                l=pnode->val;

                pnode = pnode->right;

            }

            else

            {

                return pnode->val;

            }

        }

        int minret= min(l,r);

        int maxret= max(l,r);

        return abs(target-minret)<=abs(target-maxret)?minret:maxret;

    }

};
```
#### [1490. 克隆 N 叉树](https://leetcode.cn/problems/clone-n-ary-tree/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
/*

// Definition for a Node.

class Node {

public:

    int val;

    vector<Node*> children;

  

    Node() {}

  

    Node(int _val) {

        val = _val;

    }

  

    Node(int _val, vector<Node*> _children) {

        val = _val;

        children = _children;

    }

};

*/

  

class Solution {

public:

    Node* cloneTree(Node* root) {

        if(root==nullptr)

        {

            return nullptr;

        }

        Node * pnode= root;

        Node * pret= nullptr;

        pret= new Node(pnode->val);

        if(pnode->children.empty())

        {            

            return pret;

        }

        for(Node * ptemp : pnode->children)

        {

            pret->children.push_back(cloneTree(ptemp));

        }

        return pret;

    }

};
```
#### [1506. 找到 N 叉树的根节点](https://leetcode.cn/problems/find-root-of-n-ary-tree/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
/*

// Definition for a Node.

class Node {

public:

    int val;

    vector<Node*> children;

  

    Node() {}

  

    Node(int _val) {

        val = _val;

    }

  

    Node(int _val, vector<Node*> _children) {

        val = _val;

        children = _children;

    }

};

*/

  

class Solution {

public:

    Node* findRoot(vector<Node*> tree) {

        unordered_map<int,int> umap;

        for(Node * &pnode : tree)

        {

            umap[pnode->val]++;

        }

        for(Node * &pnode : tree)

        {

            for(Node * &pnode1 : pnode->children)

            {

                umap[pnode1->val]--;

            }

        }

        int target=0;

        for(auto temp : umap)

        {

            if(temp.second!=0)

            {

                target=temp.first;

                break;

            }

        }

        Node * ptemp;

        for(auto c : tree)

        {

            if(c->val == target)

            {

                ptemp=c;

                break;

            }

        }

        return ptemp;

    }

};
```

#### [277. 搜寻名人](https://leetcode.cn/problems/find-the-celebrity/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
/* The knows API is defined for you.

      bool knows(int a, int b); */

  

class Solution {

public:

    int findCelebrity(int n) {

        vector<vector<int>> vmartix(n,vector<int>(n,0));

        vector<int> vrec(n,0);

        int ret=0;

        int findflag=0;

        int cloc=-1;

        for(int cnt_ask=0; cnt_ask<n;cnt_ask++)

        {

            findflag=0;

            for(int cnt_answer =0; cnt_answer<n;cnt_answer++)

            {

                ret=0;

                if(cnt_answer != cnt_ask)

                {

                    ret = knows(cnt_ask,cnt_answer);

                }

                vmartix[cnt_ask][cnt_answer]=ret;

                if(ret==1)

                {

                    findflag=1;

                    //break;

                }

            }

            if(findflag==0)

            {

                vrec[cnt_ask]=1;

            }

        }

        for(int cnt =0; cnt<n;cnt++)

        {

            // vector<int> vtemp = vmartix[cnt];

            // sort(vtemp.begin(),vtemp.end());

            // if(vtemp.back()==0)

            if(vrec[cnt]==1)

            {

                int flag=0;

                for(int cnttemp=0; cnttemp<n;cnttemp++)

                {

                    if(vmartix[cnttemp][cnt]==0

                       &&

                       cnttemp!=cnt)

                    {

                        flag=1;

                        break;

                    }

                }

                if(flag==0)

                {

                    findflag=1;

                    cloc = cnt;

                    break;

                }

            }

        }

        return cloc;

    }

};
```
解题思路

活用任何人都认识名人，但名人不认识任何人这一特性 如果 knows(i,j) 为ture，说明i不可能是名人 如果 knows(i,j) 为false， 说明j不可能是名人 也就说说任意两人相互比较总能淘汰一个人。 这样就可以在线性时间内找到名人，最简单的方法是迭代一遍数组

但是数组中可能不存在名人，因此需要对第一遍的结果result进行校验 校验方法是 判断数组中每个i 如果 know(result, i)或者！know(i,result)则说明result也不是名人，返回-1；

```c++
// Forward declaration of the knows API.

bool knows(int a, int b); 

class Solution {

public:

    int findCelebrity(int n) {

        int result = 0;

        for (int i = 1; i < n; ++i) {

            if (knows(result, i)) {

                result = i;

            }

        }

        for (int i = 0; i < n; ++i) {

            if (result == i) continue;

            if (knows(result, i) || !knows(i, result)) return -1;

        }

        return result;

    }

};
```

#### [1086. 前五科的均分](https://leetcode.cn/problems/high-five/description/?envType=study-plan-v2&envId=premium-algo-100)
```c++
class Solution {

public:

    vector<vector<int>> highFive(vector<vector<int>>& items) {

        sort(items.begin(),items.end(),

        [](vector<int>&a,vector<int>&b)

        {

            return a[0]<b[0];

        });

        int n=items.back()[0];

        vector<priority_queue<int>> vp(n);

        for(vector<int>&a : items)

        {

            vp[a[0]-1].push(a[1]);

        }

        vector<vector<int>> vret;

        for(int i =0; i< vp.size();i++)

        {

            int sum=0;

            int cnttemp=0;

            for(int cnt=0;cnt<5;cnt++)

            {

                if(!vp[i].empty())

                {

                    sum+=vp[i].top();

                    vp[i].pop();

                    cnttemp++;

                }

                else

                {

                    break;

                }                

            }

            int avg= cnttemp==0?0:sum/cnttemp;

            if(avg!=0)

                vret.push_back({i+1,avg});

        }

        return vret;

    }

};
```

