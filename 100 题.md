#### [1056. 易混淆数](https://leetcode.cn/problems/confusing-number/)
```c++
class Solution {

public:

    bool confusingNumber(int n) {

        vector<int> vec;

        int temp = n;

        if(n==0 || n==1 || n==8)

        {

            return false;

        }

        while(temp>0)

        {

            int r = temp%10;

            temp=temp/10;

            if(!isconfuis(r))

            {

                return false;

            }

            vec.push_back(r);      

        }

        if(vec.size()==1)

        {

            return true;

        }

        int m=1;

        int n_s=0;

        int cnt=0;

        for(cnt=0;cnt<vec.size();cnt++)

        {

            int x=retconfuis(vec[vec.size()-cnt-1]);

            n_s+=x*m;

            m=m*10;

        }

        if(n_s==n)

        {

            return false;

        }

        return true;

    }

    bool isconfuis(int n)

    {

        switch(n)

        {

            case 0:

            case 1:

            case 6:

            case 8:

            case 9:

                return true;

            case 2:

            case 3:

            case 4:

            case 5:

            case 7:

                return false;

        }

        return true;

    }

    int retconfuis(int n)

    {

        switch(n)

        {

            case 0:

                return 0;

            case 1:

                return 1;

            case 6:

                return 9;

            case 8:

                return 8;

            case 9:

                return 6;

        }

        return -1;

    }

};
```

#### [1427. 字符串的左右移](https://leetcode.cn/problems/perform-string-shifts/)
```c++
class Solution {

public:

    string stringShift(string s, vector<vector<int>>& shift) {

        string ret=s;

        for(vector<int>& vec : shift)

        {

            int shift =getreasonableshift(ret, vec[1]);

            if(vec[0]==0)

            {

                leftShift(ret, shift);

            }

            if(vec[0]==1)

            {

                rightShift(ret,shift);

            }

        }

        return ret;

    }

    int getreasonableshift(string &s,int shift)

    {

        int len=s.size();

        int ret=0;

        ret= shift%len;

        return ret;

    }

    void leftShift(string &s, int left)

    {

        string temp1 = s.substr(0,left);

        string temp2 = s.substr(left, s.size());

        s=temp2+temp1;

        return;

    }

    void rightShift(string &s, int right)

    {

        string temp1 = s.substr(0,s.size()-right);

        string temp2 = s.substr(s.size()-right, s.size());

        s=temp2+temp1;

        return;

    }

};
```

#### [624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)
```c++
class Solution {

public:

    int maxDistance(vector<vector<int>>& arrays) {

        vector<vector<int>> vec;

        int cnt=0;

        for(vector<int>& a : arrays)

        {

            vec.push_back({a.front(),cnt,a.back()});

            cnt++;

        }

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[0]<b[0];

        });

        vector<vector<int>> vecf=vec;

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[2]>b[2];

        });

        vector<vector<int>> vecb=vec;

        int ret = search(vecf,vecb,0,0);

        return ret;

    }

    int search(vector<vector<int>>& vecf,vector<vector<int>>vecb,int cntf,int cntb)

    {

        cout<<"cntf:"<<cntf<<" cntb:"<<cntb<<endl;

        cout<<vecb[cntb][2]<<","<<vecf[cntf][0]<<endl;

        if(cntf>=vecf.size())

        {

            return INT_MIN;

        }

        if(cntb>=vecb.size())

        {

            return INT_MIN;

        }

        if(vecf[cntf][1]!=vecb[cntb][1])

        {

            return vecb[cntb][2]-vecf[cntf][0];

        }

        int ret1 = search(vecf,vecb,cntf+1,cntb);

        int ret2 = search(vecf,vecb,cntf,cntb+1);

  

        int ret= max(ret1, ret2);

        return ret;

    }

};
```
#### [280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)
```c++
class Solution {

public:

    void wiggleSort(vector<int>& nums) {

        sort(nums.begin(),nums.end());

        int i=1;

        int j=2;

        int temp=0;

        while(i<nums.size() && j<nums.size())

        {

            temp=nums[i];

            nums[i]=nums[j];

            nums[j]=temp;

            i=i+2;

            j=j+2;

        }

        return;

    }

};
```

#### [161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)
双指针
```c++
class Solution {

public:

    // int flag=0;

    bool isOneEditDistance(string s, string t) {

        if(strcmp(s.c_str(),t.c_str())==0)

        {

            return false;

        }

        int ret = checkstring(s,t,0,0,0);

  

        return ret;

    }

    bool checkstring(string &s, string &t, int cnt1,int cnt2, int flag)

    {

        if(max(s.size(),t.size())-min(s.size(),t.size())>1)

        {

            return false;

        }

        if(flag>1)

        {

            return false;

        }

        if((cnt1==s.size() && cnt2==t.size()-1)||(cnt1==s.size()-1 && cnt2==t.size()))

        {

            return true;

        }

        int cnts=cnt1,cntt=cnt2;       

        int cnt=flag;

        while(cnts<s.size() && cntt < t.size())

        {

            if(s[cnts]==t[cntt])

            {

                cnts++;

                cntt++;

            }

            else

            {

                cnt++;

                int ret1 = 0 ,ret2 = 0;

                if(s.size()!=t.size())

                {

                    ret1 = checkstring(s,t,cnts,cntt+1,cnt);

                    ret2 = checkstring(s,t,cnts+1,cntt,cnt);

                }

                else

                {

                    ret1 = checkstring(s,t,cnts+1,cntt+1,cnt);

                }

                if(ret1||ret2)

                {

                    return true;

                }

                else

                {

                    return false;

                }

            }

        }

        if((cnts==s.size() && cntt != t.size()) || (cnts != s.size() && cntt == t.size()))

        {

            if(cnt!=0)

            {

                return false;

            }

        }

        return true;

    }

};
```
#### [186. 反转字符串中的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
这道题原地反转会更麻烦，需要相对坐标变换
```c++
class Solution {

public:

    void reverseWords(vector<char>& s) {

        char c = ' ';

        vector<int> vec;

        for(int cnt=0;cnt<s.size();cnt++)

        {

            if(s[cnt]==c)

            {

                vec.push_back(cnt);

            }

        }

        int prev= s.size();

        int lastp=0;

        vector<string> svec;

        int start=0;

        int end=0;

        string temp;

        for(int cnt=0;cnt<vec.size();cnt++)

        {

            end = vec[cnt];

  

            for(int subcnt=start;subcnt<end;subcnt++ )

            {

                temp+=s[subcnt];

            }

            start = end+1;

            svec.push_back(temp);

            temp.clear();

        }

        for(int subcnt=start;subcnt<s.size();subcnt++ )

        {

            temp+=s[subcnt];

        }

        svec.push_back(temp);

        string ret;

        for(int cnt = svec.size()-1;cnt>=0;cnt--)

        {

            ret+=svec[cnt];

            if(cnt!=0)

            {

                ret+=' ';

            }

        }

        for(int i=0;i<ret.size();i++)

        {

            s.push_back(ret[i]);

        }

        s.erase(s.begin(), s.begin()+ret.size());

        return;

    }

};
```


#### [159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
滑动窗口
```c++
class Solution {

public:

    int lengthOfLongestSubstringTwoDistinct(string s) {

        unordered_map<char,int> umap;

        int cnt=0;

        int left=0,right=0;

        char c;

        int len=0;

        while(right<s.size())

        {

            c= s[right];

            if(umap[c]==0)

            {

                cnt++;

            }

            umap[c]++;

            right++;

            if(cnt<=2)

            {

  

            }

            else

            {

                len = max(len,right-1-left);

                while(left<=right)

                {

                    c = s[left];

                    umap[c]--;

                    left++;

                    if(umap[c]==0)

                    {

                        cnt--;

                    }

                    if(cnt<3)

                    {

                        break;

                    }

                }                

            }

        }

        if(cnt<=2)

        {

            len=max(len,right-left);

        }

        return len;

    }

};
```

#### [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
```c++
class Solution {

public:

    int lengthOfLongestSubstringKDistinct(string s, int k) {

        unordered_map<char,int> umap;

        int cnt=0;

        int left=0,right=0;

        char c;

        int len=0;

        while(right<s.size())

        {

            c= s[right];

            if(umap[c]==0)

            {

                cnt++;

            }

            umap[c]++;

            right++;

            if(cnt<=k)

            {

                continue;

            }

            else

            {

                len = max(len,right-1-left);

                while(left<=right)

                {

                    c = s[left];

                    umap[c]--;

                    left++;

                    if(umap[c]==0)

                    {

                        cnt--;

                    }

                    if(cnt<=k)

                    {

                        break;

                    }

                }                

            }

        }

        if(cnt<=k)

        {

            len=max(len,right-left);

        }

        return len;

    }

};
```
#### [487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)
```c++
class Solution {

public:

    int findMaxConsecutiveOnes(vector<int>& nums) {

        int cnt  = 0;

        int prev = 0;

        int left=0,right=0;

        int len=0;

        int flag=0;

        for(cnt=0;cnt<nums.size();cnt++)

        {

  

            if(nums[cnt]==0)

            {

                flag=1;

                right=cnt-prev;

                len=max(right+left+1,len);

                left=right;

                prev=cnt+1;

            }

        }

  

        right=cnt-prev;

        len=max(right+left+1,len);

        if(flag==0)

        {

            return nums.size();

        }

        return len;

    }

};
```
#### [760. 找出变位映射](https://leetcode.cn/problems/find-anagram-mappings/)
```c++
class Solution {

public:

    vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {

        unordered_map<int,int> umapB;

        for(int i=0;i<nums2.size();i++)

        {

            umapB[nums2[i]]=i;

        }

        vector<int> P;

        for(int i=0;i<nums1.size();i++)

        {

            int l = umapB[nums1[i]];

            P.push_back(l);

        }

        return P;

    }

};
```
#### [266. 回文排列](https://leetcode.cn/problems/palindrome-permutation/)
```c++
class Solution {

public:

    bool canPermutePalindrome(string s) {

        unordered_map<char,int> umap;

        for(char c : s)

        {

            umap[c]++;

        }

        int flag=0;

        for(auto c : umap)

        {

            if(c.second%2!=0)

            {

                flag++;

            }

            else

            {

                ;

            }

            if(flag>1)

            {

                return false;

            }

        }

        return true;

    }

};
```
#### [734. 句子相似性](https://leetcode.cn/problems/sentence-similarity/)
```c++
class Solution {

public:

    bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {

        if(sentence1.size()!=sentence2.size())

        {

            return false;

        }

        unordered_map<string, unordered_set<string>> umapsp;

        for(auto c : similarPairs)

        {

            umapsp[c.front()].emplace(c.back());

            umapsp[c.back()].emplace(c.front());

        }

        int flag=0;

        int i=-1;

        for(auto c : sentence1)

        {

            i++;

            string & temp=sentence2[i];

            if(c==temp)

            {

                continue;

            }

            else

            {

                if(umapsp.find(c)!=umapsp.end())

                {

                    if(umapsp[c].find(temp)!=umapsp[c].end())

                    {

                        continue;

                    }

                }

            }

            return false;

        }

        return true;

    }

};
```

#### [1165. 单行键盘](https://leetcode.cn/problems/single-row-keyboard/)
```c++
class Solution {

public:

    int calculateTime(string keyboard, string word) {

        int prev=0;

        int offset=(int)'a'-0;

        int time=0;

        int cnt=0;

        unordered_map<char,int>umap;

        for(auto c : keyboard)

        {

  

            umap[c]=cnt;

            cnt++;

        }

        for(auto c :word)

        {

  

            time+=max(umap[c],prev)-min(umap[c],prev);

            prev=umap[c];

        }

        return time;

    }

};
```
