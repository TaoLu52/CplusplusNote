#### [1056. 易混淆数](https://leetcode.cn/problems/confusing-number/)
```c++
class Solution {

public:

    bool confusingNumber(int n) {

        vector<int> vec;

        int temp = n;

        if(n==0 || n==1 || n==8)

        {

            return false;

        }

        while(temp>0)

        {

            int r = temp%10;

            temp=temp/10;

            if(!isconfuis(r))

            {

                return false;

            }

            vec.push_back(r);      

        }

        if(vec.size()==1)

        {

            return true;

        }

        int m=1;

        int n_s=0;

        int cnt=0;

        for(cnt=0;cnt<vec.size();cnt++)

        {

            int x=retconfuis(vec[vec.size()-cnt-1]);

            n_s+=x*m;

            m=m*10;

        }

        if(n_s==n)

        {

            return false;

        }

        return true;

    }

    bool isconfuis(int n)

    {

        switch(n)

        {

            case 0:

            case 1:

            case 6:

            case 8:

            case 9:

                return true;

            case 2:

            case 3:

            case 4:

            case 5:

            case 7:

                return false;

        }

        return true;

    }

    int retconfuis(int n)

    {

        switch(n)

        {

            case 0:

                return 0;

            case 1:

                return 1;

            case 6:

                return 9;

            case 8:

                return 8;

            case 9:

                return 6;

        }

        return -1;

    }

};
```

#### [1427. 字符串的左右移](https://leetcode.cn/problems/perform-string-shifts/)
```c++
class Solution {

public:

    string stringShift(string s, vector<vector<int>>& shift) {

        string ret=s;

        for(vector<int>& vec : shift)

        {

            int shift =getreasonableshift(ret, vec[1]);

            if(vec[0]==0)

            {

                leftShift(ret, shift);

            }

            if(vec[0]==1)

            {

                rightShift(ret,shift);

            }

        }

        return ret;

    }

    int getreasonableshift(string &s,int shift)

    {

        int len=s.size();

        int ret=0;

        ret= shift%len;

        return ret;

    }

    void leftShift(string &s, int left)

    {

        string temp1 = s.substr(0,left);

        string temp2 = s.substr(left, s.size());

        s=temp2+temp1;

        return;

    }

    void rightShift(string &s, int right)

    {

        string temp1 = s.substr(0,s.size()-right);

        string temp2 = s.substr(s.size()-right, s.size());

        s=temp2+temp1;

        return;

    }

};
```

#### [624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)
```c++
class Solution {

public:

    int maxDistance(vector<vector<int>>& arrays) {

        vector<vector<int>> vec;

        int cnt=0;

        for(vector<int>& a : arrays)

        {

            vec.push_back({a.front(),cnt,a.back()});

            cnt++;

        }

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[0]<b[0];

        });

        vector<vector<int>> vecf=vec;

        sort(vec.begin(),vec.end(),[](vector<int> &a, vector<int> &b)

        {

            return a[2]>b[2];

        });

        vector<vector<int>> vecb=vec;

        int ret = search(vecf,vecb,0,0);

        return ret;

    }

    int search(vector<vector<int>>& vecf,vector<vector<int>>vecb,int cntf,int cntb)

    {

        cout<<"cntf:"<<cntf<<" cntb:"<<cntb<<endl;

        cout<<vecb[cntb][2]<<","<<vecf[cntf][0]<<endl;

        if(cntf>=vecf.size())

        {

            return INT_MIN;

        }

        if(cntb>=vecb.size())

        {

            return INT_MIN;

        }

        if(vecf[cntf][1]!=vecb[cntb][1])

        {

            return vecb[cntb][2]-vecf[cntf][0];

        }

        int ret1 = search(vecf,vecb,cntf+1,cntb);

        int ret2 = search(vecf,vecb,cntf,cntb+1);

  

        int ret= max(ret1, ret2);

        return ret;

    }

};
```
#### [280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)
```c++
class Solution {

public:

    void wiggleSort(vector<int>& nums) {

        sort(nums.begin(),nums.end());

        int i=1;

        int j=2;

        int temp=0;

        while(i<nums.size() && j<nums.size())

        {

            temp=nums[i];

            nums[i]=nums[j];

            nums[j]=temp;

            i=i+2;

            j=j+2;

        }

        return;

    }

};
```

#### [161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)
双指针
```c++
class Solution {

public:

    // int flag=0;

    bool isOneEditDistance(string s, string t) {

        if(strcmp(s.c_str(),t.c_str())==0)

        {

            return false;

        }

        int ret = checkstring(s,t,0,0,0);

  

        return ret;

    }

    bool checkstring(string &s, string &t, int cnt1,int cnt2, int flag)

    {

        if(max(s.size(),t.size())-min(s.size(),t.size())>1)

        {

            return false;

        }

        if(flag>1)

        {

            return false;

        }

        if((cnt1==s.size() && cnt2==t.size()-1)||(cnt1==s.size()-1 && cnt2==t.size()))

        {

            return true;

        }

        int cnts=cnt1,cntt=cnt2;       

        int cnt=flag;

        while(cnts<s.size() && cntt < t.size())

        {

            if(s[cnts]==t[cntt])

            {

                cnts++;

                cntt++;

            }

            else

            {

                cnt++;

                int ret1 = 0 ,ret2 = 0;

                if(s.size()!=t.size())

                {

                    ret1 = checkstring(s,t,cnts,cntt+1,cnt);

                    ret2 = checkstring(s,t,cnts+1,cntt,cnt);

                }

                else

                {

                    ret1 = checkstring(s,t,cnts+1,cntt+1,cnt);

                }

                if(ret1||ret2)

                {

                    return true;

                }

                else

                {

                    return false;

                }

            }

        }

        if((cnts==s.size() && cntt != t.size()) || (cnts != s.size() && cntt == t.size()))

        {

            if(cnt!=0)

            {

                return false;

            }

        }

        return true;

    }

};
```
#### [186. 反转字符串中的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
这道题原地反转会更麻烦，需要相对坐标变换
```c++
class Solution {

public:

    void reverseWords(vector<char>& s) {

        char c = ' ';

        vector<int> vec;

        for(int cnt=0;cnt<s.size();cnt++)

        {

            if(s[cnt]==c)

            {

                vec.push_back(cnt);

            }

        }

        int prev= s.size();

        int lastp=0;

        vector<string> svec;

        int start=0;

        int end=0;

        string temp;

        for(int cnt=0;cnt<vec.size();cnt++)

        {

            end = vec[cnt];

  

            for(int subcnt=start;subcnt<end;subcnt++ )

            {

                temp+=s[subcnt];

            }

            start = end+1;

            svec.push_back(temp);

            temp.clear();

        }

        for(int subcnt=start;subcnt<s.size();subcnt++ )

        {

            temp+=s[subcnt];

        }

        svec.push_back(temp);

        string ret;

        for(int cnt = svec.size()-1;cnt>=0;cnt--)

        {

            ret+=svec[cnt];

            if(cnt!=0)

            {

                ret+=' ';

            }

        }

        for(int i=0;i<ret.size();i++)

        {

            s.push_back(ret[i]);

        }

        s.erase(s.begin(), s.begin()+ret.size());

        return;

    }

};
```
