- 455:  贪心算法，平铺直叙
- 135：核心思路是使用贪心策略正遍历一遍，之后再反遍历一遍来弥补。
- 435:   
	1. 按照右端点从小到大排序。
	2. 从左向右遍历，比较遍历到的元素和已经确定需要的元素是否重合。
	3. 注意重合的判断条件：
	```c++
	intervals[cnt][0]<vrec.back()[1]
	```
- 167: 双指针
- 144: 二叉树
- 142: 快慢指针
- 76:   双指针--滑动窗口
- 633: 双指针，但是注意初始值可以选择input的开方，同时要用long型防止溢出
- 69: 二分查找最重要的注意点：
	- 左右端点的变化
	- 减半时不能引起震荡
- 347: 二分查找左右端点变化依然不够熟
- 695: DFS 注意收敛条件以及每层结果怎样传递给上层
- 547: 不要机械化的套用图搜索的算法。
- 417: 正向DFS可以做，但是特殊情况较多。逆向思维看海水可以流到哪里更好。
- 46:  回溯全排列，需要做好每一层的状态恢复
- 77:  和46题比，需要多一个入参来记录上一层的状态
- 934: 自己的解法超时了, 解法中遗漏的一点是没一个访问到的值为0的节点，在入vector时也可以置为3，这样可以避免许多重复访问时间
- 70: 动态规划，建立状态数组的时候注意输入为n时，如果要直接使用数组大小应该为n+1
- 198: 和70题类似
- 413: 这道题的关键是要找到状态转移的关系：![[Pasted image 20231019162552.png]]
- 64: 至少从这道题看，二维和一维的思想是差不多的。这道题的特殊点在于1. 要逆向一下，从后往前；2. 要注意右下角是特殊点，单独处理。
- 542: 使用返回矩阵作为状态矩阵，需要从左上角先 遍历一遍，再从右下角反向遍历一遍。可以改进的点在于，第一遍遍历时，元素右边和下边的肯定没有算到，不需要管，而第二遍，只需要管第一遍没有遍历到的右边和下边的元素
- 